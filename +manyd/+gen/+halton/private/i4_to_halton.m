function r = i4_to_halton ( dim_num, step, seed, leap, base )

%*****************************************************************************80
%
%% I4_TO_HALTON computes an element of a leaped Halton subsequence.
%
%  Discussion:
%
%    The DIM_NUM-dimensional Halton sequence is really DIM_NUM separate
%    sequences, each generated by a particular base.
%
%    This routine selects elements of a "leaped" subsequence of the 
%    Halton sequence.  The subsequence elements are indexed by a
%    quantity called STEP, which starts at 0.  The STEP-th subsequence 
%    element is simply element 
%
%      SEED(1:DIM_NUM) + STEP * LEAP(1:DIM_NUM) 
%
%    of the original Halton sequence.
%
%  Licensing:
%
%    This code is distributed under the GNU LGPL license.
%
%  Modified:
%
%    21 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Reference:
%
%    J H Halton,
%    On the efficiency of certain quasi-random sequences of points
%    in evaluating multi-dimensional integrals,
%    Numerische Mathematik,
%    Volume 2, 1960, pages 84-90.
% 
%    J H Halton and G B Smith,
%    Algorithm 247: Radical-Inverse Quasi-Random Point Sequence,
%    Communications of the ACM,
%    Volume 7, 1964, pages 701-702.
%
%    Ladislav Kocis and William Whiten,
%    Computational Investigations of Low-Discrepancy Sequences,
%    ACM Transactions on Mathematical Software,
%    Volume 23, Number 2, 1997, pages 266-294.
%
%  Parameters:
%
%    Input, integer DIM_NUM, the spatial dimension.
%    1 <= DIM_NUM is required.
%
%    Input, integer STEP, the index of the subsequence element.
%    0 <= STEP is required.
%
%    Input, integer SEED(DIM_NUM), the Halton sequence index corresponding 
%    to STEP = 0.
%    0 <= SEED(1:DIM_NUM) is required.
%
%    Input, integer LEAP(DIM_NUM), the successive jumps in the Halton sequence.
%    1 <= LEAP(1:DIM_NUM) is required.
%
%    Input, integer BASE(DIM_NUM), the Halton bases.
%    1 < BASE(1:DIM_NUM) is required.
%
%    Output, real R(DIM_NUM), the STEP-th element of the leaped 
%    Halton subsequence.
%
  dim_num = floor ( dim_num );
  step = floor ( step );
  seed(1:dim_num) = floor ( seed(1:dim_num) );
  leap(1:dim_num) = floor ( leap(1:dim_num) );
  base(1:dim_num) = floor ( base(1:dim_num) );
%
%  Check the input.
%
  if ( ~halham_dim_num_check ( dim_num ) )
    error ( 'I4_TO_HALTON - Fatal error!' );
  end

  if ( ~halham_step_check ( step ) )
    error ( 'I4_TO_HALTON - Fatal error!' );
  end

  if ( ~halham_seed_check ( dim_num, seed ) )
    error ( 'I4_TO_HALTON - Fatal error!' );
  end

  if ( ~halham_leap_check ( dim_num, leap ) )
    error ( 'I4_TO_HALTON - Fatal error!' );
  end

  if ( ~halton_base_check ( dim_num, base ) )
    error ( 'I4_TO_HALTON - Fatal error!' );
  end
%
%  Calculate the data.
%
  seed2(1:dim_num) = seed(1:dim_num) + step * leap(1:dim_num);

  r(1:dim_num) = 0.0;

  base_inv(1:dim_num) = 1.0 ./ base(1:dim_num);
  
  while ( any ( seed2(1:dim_num) ~= 0 ) )
    digit(1:dim_num) = mod ( seed2(1:dim_num), base(1:dim_num) );
    r(1:dim_num) = r(1:dim_num) + digit(1:dim_num) .* base_inv(1:dim_num);
    base_inv(1:dim_num) = base_inv(1:dim_num) ./ base(1:dim_num);
    seed2(1:dim_num) = floor ( seed2(1:dim_num) ./ base(1:dim_num) );
  end

  return
end
